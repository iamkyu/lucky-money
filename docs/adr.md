# Architectural Decision Records

## 핵심문제해결전략

동시성 문제 해결을 위한 방법은 다음을 기준으로 판단.

(1) 요구사항의 충족 (2) 동시성의 최대화 (3) 코드의 복잡도 최소화



### 돈 받기 문제

이 문제는 다시 두 문제로 분할할 수 있다고 판단.



#### 1.돈을 잘 분배하는 문제

- 돈 받기 요청이 들어올때마다 얼마를 나눠줄지 판단하기엔 너무 복잡함.
- 따라서 게임 생성 시점에 이미 당첨 금액은 분배해서 저장해둠.(`GameAward`)



#### 2.분배 된 돈 만큼만 나눠줄 수 있는 문제 (동시성)

- 선점(비관적) 잠금 방식이 불가피 해보임.
- 다만, End-to-End 의 끝점인 RDS 에 모든 잠금을 의존하여 해결 하면 장기적으로 RDS 가 병목 지점이 될 가능성이 높아 보임. (계속 증가하는 데이터, S-Lock 으로 인한 교착상태 유발 등)
- 따라서 Atomic 한 연산이 가능하고 확장 가능한 솔루션 중 레디스를 선택. 일종의 오프라인 선점 잠금 방식을 구현.
    - 돈 받기 트랜잭션 시작시 레디스에서 '돈 받기 번호표'를 하나 뽑음.
    - 트랜잭션이 성공한다면 번호표를 반납하지 않고, RDS 에서 해당 번호표의 상태를 변경.
    - RDS 에서도 상태 관리한 이유는 레디스에 문제 발생시 RDS 만으로 처리 가능하도록 추후 구현되어야 함.
    - 만약 트랜잭션이 실패한다면 번호표를 다시 반환.
    - 트레이드 오프는 추가적인 인프라 관리 비용, SPOF, 사용자의 Non-Repeatable Read 경험 가능성.
- 한 게임에 한 사람은 오직 한번만 받을 수 있는 요구사항은 데이터베이스 유니크 제약 조건으로 해결.



### 게임 생성시 토큰 발급 문제

돈 받기 문제와 마찬가지로 두 문제로 분할할 수 있다고 판단.



#### 1.유니크한 토큰을 생성하는 문제

- 대소문자, 숫자 조합으로 생성하는 3글자 토큰은 생성 가능한 수가 정해져 있음. (62^3)
- 많은 데이터가 아니기 때문에 미리 생성해두고 저장해두는 시나리오를 계획.
- 그리고 게임방 - 토큰 사이에 메타 데이터를 두고 마지막 사용한 토큰의 오프셋을 관리. (`TokenMeta`)



#### 2.토큰을 각 게임방에서 한번만 사용할 수 있도록 하는 문제 (동시성)

- 돈 받기에 비하면 충돌 가능성이 낮아 보임. 따라서 여기서는 비선점(낙관적) 잠금 방식을 활용.
- 게임 생성 트랜잭션 시점 시점에 새로운 트랜잭션을 열고 해당 게임을 위한 토큰을 확보하고 시작.
- 게임 생성 트랜잭션이 실패할 수 있지만, 실패에 따라 토큰을 재사용 가능하게 되돌려 놓는것 보다 토큰을 버리는 것이 코드와 시스템의 복잡성을 줄인다고 판단.





## 더 고민해 볼 문제들

- 게임방은 영구적이지만 게임은 비영구적임. 즉, 일정 기간이 지난 후 토큰을 재사용할 수 있어야 함. 현재는 불가.
- 위 요구사항이 가능하게 된다면, 악의적인 의도를 가진 사용자가 토큰의 순서를 유추할 수도 있음.
- 레디스에 문제가 생겼을 때 Fallback 로직을 어떻게 구현할 것인가?
- 돈 받기시 예상치 못하게 트랜잭션이 길어졌을 때를 대비해 오프라인 잠금의 타임 아웃이 필요하지 않을까?